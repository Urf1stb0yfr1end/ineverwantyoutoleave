<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beat-em-up Street Walk</title>
  <style>
    html, body { margin:0; height:100%; background:#05070d; overflow:hidden; }
    canvas { width:100vw; height:100vh; display:block; image-rendering: pixelated; }
    .hud{
      position:fixed; left:12px; top:12px;
      color:#d7e6ff; font:14px system-ui,Segoe UI,Arial;
      background:rgba(0,0,0,.35);
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      user-select:none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div class="hud"><b>Arrow keys / WASD</b> move â€¢ Shift = run</div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const bg = new Image(); bg.src = "background.png";
  const ch = new Image(); ch.src = "character.png";

  const keys = new Set();
  addEventListener("keydown", (e) => { keys.add(e.key.toLowerCase()); });
  addEventListener("keyup", (e) => { keys.delete(e.key.toLowerCase()); });

  // Resize canvas to ALWAYS match the browser window (true fullscreen)
  function resize() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const w = Math.floor(innerWidth);
    const h = Math.floor(innerHeight);

    // match CSS size
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";

    // real pixel buffer (crisp on HiDPI)
    canvas.width = w * dpr;
    canvas.height = h * dpr;

    // draw in CSS pixel coords
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener("resize", resize);
  resize();

  // "Street lane" (walkable vertical strip) in *screen coords*
  // These are ratios so it adapts to any resolution.
  // If your street is higher/lower, tweak these.
  const streetTopRatio = 0.56;     // ~300/540
  const streetBottomRatio = 0.935; // ~505/540

  // Optional: allow horizontal scrolling if map wider than screen
  // We'll compute this after bg loads.
  let mapScrollMax = 0;

  const player = {
    x: 280,
    y: 440,
    baseW: 56,
    baseH: 56,
    speed: 240
  };

  let camX = 0;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function streetTop()    { return innerHeight * streetTopRatio; }
  function streetBottom() { return innerHeight * streetBottomRatio; }

  function depthScale(y){
    const top = streetTop();
    const bot = streetBottom();
    const t = (y - top) / (bot - top);
    return 0.70 + t * 0.55;
  }

  // Background draw: COVER the screen so nothing is "out of page".
  // (fills entire browser; crops edges if aspect ratios differ)
  function drawBg(){
    const cw = innerWidth, chh = innerHeight;

    if (bg.complete && bg.naturalWidth) {
      const iw = bg.naturalWidth, ih = bg.naturalHeight;

      // Compute cover scale
      const s = Math.max(cw / iw, chh / ih);
      const dw = iw * s;
      const dh = ih * s;

      // Centered draw position, then apply camera on X
      // We allow camX only within the drawable overflow.
      const baseX = (cw - dw) / 2;
      const baseY = (chh - dh) / 2;

      // How much extra width exists beyond the screen (scrollable area)
      const overflowX = Math.max(0, dw - cw);
      mapScrollMax = overflowX; // world scroll in "screen pixels"

      // camX scrolls within overflow range
      const x = baseX - camX;
      const y = baseY;

      ctx.drawImage(bg, x, y, dw, dh);
    } else {
      ctx.fillStyle = "#0b1020";
      ctx.fillRect(0,0,cw,chh);
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fillText("Loading background.png...", 24, 36);
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = (now - last) / 1000;
    last = now;

    const top = streetTop();
    const bot = streetBottom();

    const run = keys.has("shift") ? 1.55 : 1.0;
    const sp = player.speed * run;

    let vx = 0, vy = 0;
    const left  = keys.has("arrowleft")  || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    const up    = keys.has("arrowup")    || keys.has("w");
    const down  = keys.has("arrowdown")  || keys.has("s");

    if (left) vx -= 1;
    if (right) vx += 1;
    if (up) vy -= 1;
    if (down) vy += 1;

    if (vx && vy) { vx *= 0.7071; vy *= 0.7071; }

    player.x += vx * sp * dt;
    player.y += vy * sp * dt;

    // lock player to street bounds (Batman style)
    player.y = clamp(player.y, top, bot);

    // subtle depth speed feeling
    player.x += vx * (sp * 0.15) * (1 - (player.y - top) / (bot - top)) * dt;

    // keep player.x sane
    player.x = clamp(player.x, 0, 999999);

    // Camera follow: if background has overflow after "cover", allow scrolling
    if (mapScrollMax > 0) {
      const targetCam = (player.x - innerWidth * 0.45);
      camX = clamp(targetCam, 0, mapScrollMax);
    } else {
      camX = 0;
    }

    // Draw
    ctx.clearRect(0,0,innerWidth,innerHeight);
    drawBg();

    // Draw player with depth scale + shadow
    const s = depthScale(player.y);
    const w = player.baseW * s;
    const h = player.baseH * s;

    const px = Math.floor(player.x - camX);
    const py = Math.floor(player.y - h);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(px + w/2, py + h - 6, w*0.32, h*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    if (ch.complete && ch.naturalWidth) {
      ctx.drawImage(ch, px, py, w, h);
    } else {
      ctx.fillStyle = "#8fe3ff";
      ctx.fillRect(px, py, w, h);
    }

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
