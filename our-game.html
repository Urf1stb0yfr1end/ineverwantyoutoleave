<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beat-em-up Street Walk</title>
  <style>
    html, body { margin:0; height:100%; background:#05070d; overflow:hidden; }
    canvas { width:100vw; height:100vh; display:block; image-rendering: pixelated; }
    .hud{
      position:fixed; left:12px; top:12px;
      color:#d7e6ff; font:14px system-ui,Segoe UI,Arial;
      background:rgba(0,0,0,.35);
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      user-select:none;
      z-index:10;
    }
  </style>
</head>
<body>
  <div class="hud"><b>Arrow keys / WASD</b> move â€¢ Shift = run</div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // Assets (keep in same folder as this HTML, or update paths)
  const bg = new Image(); bg.src = "background.png";
  const ch = new Image(); ch.src = "character.png";

  // Input
  const keys = new Set();
  addEventListener("keydown", (e) => { keys.add(e.key.toLowerCase()); });
  addEventListener("keyup", (e) => { keys.delete(e.key.toLowerCase()); });

  // Fullscreen canvas, crisp pixels on HiDPI
  let DPR = 1;
  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const w = Math.floor(innerWidth);
    const h = Math.floor(innerHeight);

    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w * DPR;
    canvas.height = h * DPR;

    // draw in CSS pixel coordinates
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener("resize", resize);
  resize();

  // Street lane bounds
  const streetTopRatio = 0.76; // tweak if your street starts higher/lower
  const bottomPad = 0;         // set 1-4 if you see bottom clipping
  const streetTop = () => innerHeight * streetTopRatio;
  const streetBottom = () => innerHeight - bottomPad;

  // Background scaling: STRETCH to touch all 4 corners
  function drawBgStretch(){
    const cw = innerWidth, chh = innerHeight;
    if (bg.complete && bg.naturalWidth) {
      ctx.drawImage(bg, 0, 0, cw, chh);
    } else {
      ctx.fillStyle = "#0b1020";
      ctx.fillRect(0,0,cw,chh);
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fillText("Loading background.png...", 24, 36);
    }
  }

  // Player
  const player = {
    x: 280,
    y: 440,
    baseW: 112,  // 2x bigger
    baseH: 112,  // 2x bigger
    speed: 240
  };

  // Optional camera scrolling (off)
  const mapScrollMax = 0;
  let camX = 0;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Mild depth effect so he doesn't shrink a ton when moving upward
  const spriteScale = 1.0; // keep 1.0 since baseW/baseH already doubled
  function depthScale(y){
    const top = streetTop();
    const bot = streetBottom();
    const t = (y - top) / (bot - top); // 0..1
    const depth = 0.95 + t * 0.15;     // far 0.95 -> near 1.10 (small change)
    return depth * spriteScale;
  }

  let last = performance.now();
  function loop(now){
    const dt = (now - last) / 1000;
    last = now;

    const top = streetTop();
    const bot = streetBottom();

    const run = keys.has("shift") ? 1.55 : 1.0;
    const sp = player.speed * run;

    let vx = 0, vy = 0;
    const left  = keys.has("arrowleft")  || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    const up    = keys.has("arrowup")    || keys.has("w");
    const down  = keys.has("arrowdown")  || keys.has("s");

    if (left) vx -= 1;
    if (right) vx += 1;
    if (up) vy -= 1;
    if (down) vy += 1;

    if (vx && vy) { vx *= 0.7071; vy *= 0.7071; }

    player.x += vx * sp * dt;
    player.y += vy * sp * dt;

    // Lock to street lane; allow feet to reach the bottom edge
    player.y = clamp(player.y, top, bot);

    // Subtle depth speed feeling (optional)
    player.x += vx * (sp * 0.15) * (1 - (player.y - top) / (bot - top)) * dt;

    // Keep x sane
    player.x = clamp(player.x, 0, 999999);

    // Camera follow (off by default)
    camX = (mapScrollMax > 0)
      ? clamp(player.x - innerWidth * 0.45, 0, mapScrollMax)
      : 0;

    // Draw
    ctx.clearRect(0,0,innerWidth,innerHeight);
    drawBgStretch();

    const s = depthScale(player.y);
    const w = player.baseW * s;
    const h = player.baseH * s;

    // player.y is the "feet line"
    const px = Math.floor(player.x - camX);
    const py = Math.floor(player.y - h);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(px + w/2, player.y - 6, w*0.32, h*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    if (ch.complete && ch.naturalWidth) {
      ctx.drawImage(ch, px, py, w, h);
    } else {
      ctx.fillStyle = "#8fe3ff";
      ctx.fillRect(px, py, w, h);
    }

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
